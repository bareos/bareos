#!/bin/bash

#   BAREOSÂ® - Backup Archiving REcovery Open Sourced
#
#   Copyright (C) 2025-2026 Bareos GmbH & Co. KG
#
#   This program is Free Software; you can redistribute it and/or
#   modify it under the terms of version three of the GNU Affero General Public
#   License as published by the Free Software Foundation and included
#   in the file LICENSE.
#
#   This program is distributed in the hope that it will be useful, but
#   WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
#   Affero General Public License for more details.
#
#   You should have received a copy of the GNU Affero General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
#   02110-1301, USA.

# This testrunner performs a backup and a restore for each pool / volume

set -e
set -o pipefail
set -u

TestName="$(basename "$(pwd)")"
export TestName

#shellcheck source=../../environment.in
. ./environment
#shellcheck source=test-config.in
. ./test-config

#shellcheck source=../../scripts/functions
. "${BAREOS_SCRIPTS_DIR}"/functions

start_test

on_error()
{
  local lc="${BASH_COMMAND}"
  echo "Error occurred in testrunner script [${lc}]"
  export estat=1
  exit 1
}
trap 'on_error' ERR

# remove jobs from previous runs
cat <<END_OF_DATA >"${runner_tmp}/bconcmds"
@$out ${runner_tmp}/log-purge.out
purge jobs client=bareos-fd yes
wait
messages
quit
END_OF_DATA

run_bconsole "${runner_tmp}/bconcmds"

echo "Set debug on the Tape-Storage daemon and dir"
tracefile="$(bin/bconsole <<<"setdebug level=250 trace=1 storage=Tape-0" | awk -F"tracefile=" '/^3000/ {print $2}')"
: >"${tracefile}" # clear tracefile

tracefile="$(bin/bconsole <<<"setdebug level=250 trace=1 dir" | awk -F"tracefilename=" '/tracefilename=/ {print $2}')"
: >"${tracefile}" # clear tracefile

echo "Label barcodes"
for i in $(seq ${NUMBER_OF_POOLS}); do
  pool=$((i - 1)) #counts from 0
  for j in $(seq ${NUMBER_OF_TAPES_PER_POOL}); do
    slot=$((j + pool * NUMBER_OF_TAPES_PER_POOL)) #counts from 1
    echo "label barcodes slot=${slot} drive=0 pool=Full-${pool} storage=Tape-0 yes" | bin/bconsole | grep -E "(OK label|already exists)"
  done
done

# create the test backup jobs
rm -f "${runner_tmp}/bconsole_backup_jobs"

spooling="spooldata=yes"
for i in $(seq ${NUMBER_OF_TEST_ROUNDS}); do
  for j in $(seq ${NUMBER_OF_POOLS}); do
    cat <<EOF >>"${runner_tmp}/bconsole_backup_jobs"
run job=backup-bareos-fd level=Full storage=Tape-0 pool=Full-$((j - 1)) ${spooling} yes
status dir
EOF
    if [ $((NUMBER_OF_SPOOLING_JOBS_PER_ROUND - j)) -le 0 ]; then
      spooling=""
    fi
  done
done

echo "wait" >>"${runner_tmp}/bconsole_backup_jobs"
echo "messages" >>"${runner_tmp}/bconsole_backup_jobs"

# start all the jobs
run_bconsole "${runner_tmp}/bconsole_backup_jobs"

# prepare the restore
list_of_jobids=$(
  bin/bconsole <<<".api 2
list jobs job=backup-bareos-fd jobstatus=T,W
" | awk -F ":" '/^.*"jobid":/ {gsub("\"","",$2);gsub(" ","",$2);gsub(",","",$2);print $2}'
)

if [ -z "${list_of_jobids}" ]; then
  echo "no jobs found for restore"
  export estat=1
  exit 1
fi
# Write list of jobids for next use
echo "${list_of_jobids}" >"${tmp}/list_of_jobids"

# Use restore with jobid
rm -f "${runner_tmp}/bconsole_restore_jobs"
echo "@out ${runner_tmp}/bconsole_restore_jobs.out" >>"${runner_tmp}/bconsole_restore_jobs"

for j in ${list_of_jobids}; do
  cat <<EOF >>"${runner_tmp}/bconsole_restore_jobs"
restore jobid=${j} where=${tmp}/bareos_restores_${j} all done yes
EOF
done

echo "wait" >>"${runner_tmp}/bconsole_restore_jobs"
echo "messages" >>"${runner_tmp}/bconsole_restore_jobs"

# start all the restore jobs
run_bconsole "${runner_tmp}/bconsole_restore_jobs"

# does not compare fifo files
for j in ${list_of_jobids}; do
  src="${tmp}/data"
  dst="${tmp}/bareos_restores_${j}/${tmp}/data"
  diff --exclude="fifo*" --brief --recursive --no-dereference \
    "$src" "$dst"
done

end_test
